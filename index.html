<!doctype html>
<html lang="en">

<head>
    <title>Disco Dance Floor</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

    <style>
        body {
            background-color: grey;
        }

        canvas {
            background-color: white;
        }
    </style>

    <script src="http://localhost/DiscoSimulatorWebGL/OBJLoader.js"></script>
    <script src="http://localhost/DiscoSimulatorWebGL/webgl-utils.js"></script>
    <script src="http://localhost/DiscoSimulatorWebGL/disco.js"></script>

    <script id="shader-fs" type="x-shader/x-fragment">
        void main() { gl_FragColor = (0.0, 0.0, 0.0); }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition; void main() { gl_Position = aVertexPosition; }
    </script>

    <script type='text/javascript'>
        var gl;

        function loadShader(gl, id) {
            var shaderScript = document.getElementByID(id);
            if (!shaderScript)
                return null;

            var str = "";
            var k = shaderScript.firstChild;

            while (k) {
                if (k.nodeType == 3) {
                    str += k.textContent;
                }
                k = k.nextSibling;
            }

            var shader;
            if (shaderScript.type == "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type == "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }

            gl.shaderSource(shader, str);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function initShaders() {

            var fragmentShader = getShader(gl, "shader-fs");
            var vertexShader = getShader(gl, "shader-vs");
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
            gl.useProgram(shaderProgram);
            aVertexPosition = gl.getAttribLocation(shaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(aVertexPosition);
            aPlotPosition = gl.getAttribLocation(shaderProgram, "aPlotPosition");
            gl.enableVertexAttribArray(aPlotPosition);

        }

        function readTextFile(filePath) {
            var fileText = new XMLHttpRequest();
            fileText.open("GET", filePath, true);
            fileText.onreadystatechange = function() {
                if (fileText.readyState === 4) {
                    if (fileText.status === 200 || fileText.status == 0) {
                        alert(fileText.responseText);
                        return fileText.responseText;
                    }
                }
            }
            fileText.send(null);
        }

        var vertexBuffer, normalBuffer, indexBuffer;

        function loadJSON(jsonData) {
            normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(jsonData.vertexNormals), gl.STATIC_DRAW);
            normalBuffer.itemSize = 3;
            normalBuffer.numItems = jsonData.vertexNormals.length / 3;
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(jsonData.vertexPositions), gl.STATIC_DRAW);
            vertexBuffer.itemSize = 3;
            vertexBuffer.numItems = jsonData.vertexPositions.length / 3;
            indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(jsonData.indices), gl.STATIC_DRAW);
            indexBuffer.itemSize = 1;
            indexBuffer.numItems = jsonData.indices.length;
        }

        function drawScene() {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            if (normalBuffer == null || vertexBuffer == null || indexBuffer == null) {
                return;
            }
        }

        function initGL(canvas) {
            try {
                gl = canvas.getContext("webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
            } catch (e) {

            }
            if (!gl) {
                alert("Could not initialise WebGL, sorry :-(");
            }
        }

        function webGLStart() {
            var canvas = document.getElementById("webgl");
            initGL(canvas);
            loadJSON();
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            drawScene();
        }
    </script>
</head>

<body onLoad="webGLStart();">
    <canvas id="webgl" width="400" height="400">
        Your browser does not support the HTML5 canvas element.
    </canvas>

</body>

</html>
